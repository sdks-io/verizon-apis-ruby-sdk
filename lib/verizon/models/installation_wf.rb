# verizon
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

module Verizon
  # `installationWf` attribute of a service.
  class InstallationWf < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # TODO: Write general description for this method
    # @return [HookTypeEnum]
    attr_accessor :hook_type

    # Allowed values are: GIT files (PULL_FROM_REPO), MANUAL_UPLOAD.
    # @return [UploadTypeEnum]
    attr_accessor :upload_type

    # Repository ID of an existing repository.
    # @return [String]
    attr_accessor :repository_id

    # Users can create a repository to maintain service artifacts. Repository
    # would be either a Git or HELM repository.
    # @return [Repository]
    attr_accessor :repository

    # Source code type can be JAVA or GO.
    # @return [SourceCodeTypeEnum]
    attr_accessor :source_code_type

    # Revision type can be a BRANCH or TAG.
    # @return [WorkloadRevisionTypeEnum]
    attr_accessor :revision_type

    # Branch or tag name.
    # @return [String]
    attr_accessor :name

    # The workflow path.
    # @return [String]
    attr_accessor :path

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['hook_type'] = 'hookType'
      @_hash['upload_type'] = 'uploadType'
      @_hash['repository_id'] = 'repositoryId'
      @_hash['repository'] = 'repository'
      @_hash['source_code_type'] = 'sourceCodeType'
      @_hash['revision_type'] = 'revisionType'
      @_hash['name'] = 'name'
      @_hash['path'] = 'path'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        hook_type
        upload_type
        repository_id
        repository
        source_code_type
        revision_type
        name
        path
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(hook_type = SKIP,
                   upload_type = SKIP,
                   repository_id = SKIP,
                   repository = SKIP,
                   source_code_type = SKIP,
                   revision_type = SKIP,
                   name = SKIP,
                   path = SKIP)
      @hook_type = hook_type unless hook_type == SKIP
      @upload_type = upload_type unless upload_type == SKIP
      @repository_id = repository_id unless repository_id == SKIP
      @repository = repository unless repository == SKIP
      @source_code_type = source_code_type unless source_code_type == SKIP
      @revision_type = revision_type unless revision_type == SKIP
      @name = name unless name == SKIP
      @path = path unless path == SKIP
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      hook_type = hash.key?('hookType') ? hash['hookType'] : SKIP
      upload_type = hash.key?('uploadType') ? hash['uploadType'] : SKIP
      repository_id = hash.key?('repositoryId') ? hash['repositoryId'] : SKIP
      repository = Repository.from_hash(hash['repository']) if hash['repository']
      source_code_type =
        hash.key?('sourceCodeType') ? hash['sourceCodeType'] : SKIP
      revision_type = hash.key?('revisionType') ? hash['revisionType'] : SKIP
      name = hash.key?('name') ? hash['name'] : SKIP
      path = hash.key?('path') ? hash['path'] : SKIP

      # Create object from extracted values.
      InstallationWf.new(hook_type,
                         upload_type,
                         repository_id,
                         repository,
                         source_code_type,
                         revision_type,
                         name,
                         path)
    end
  end
end
